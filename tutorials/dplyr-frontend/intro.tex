% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
  \usepackage{amssymb}
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Using the dplyr frontend to query MIMIC-III},
  pdfauthor={Beverly Anne Setzer; Lauren Nicole Geiser; Jason Cory Brunson},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Using the \textbf{dplyr} frontend to query MIMIC-III}
\author{Beverly Anne Setzer \and Lauren Nicole Geiser \and Jason Cory
Brunson}
\date{05 March 2021}

\begin{document}
\maketitle

\hypertarget{introduction}{%
\subsection{Introduction}\label{introduction}}

This tutorial shows how MIMIC-III can be queried using \textbf{dplyr}.
Only several basic queries are performed, though
\href{https://dbplyr.tidyverse.org/}{the \textbf{dbplyr} package}, which
powers SQL queries in \textbf{dplyr},
\href{https://github.com/tidyverse/dbplyr/issues}{is still maturing},
and much functionality exists that is not showcased here.

\hypertarget{example-workflow}{%
\subsubsection{Example workflow}\label{example-workflow}}

The following workflow is a simplified version of several scripts used
to study medical and social risk factors for heart attack patients. The
goal is to prepare an analytic table containing, for each eligible
admission, values of several variables that might be used in a
statistical analysis. My syntactical conventions --- using
\textbf{tidyverse} packages and, in particular, ending piped function
compositions with
\texttt{\%\textgreater{}\%\ print()\ -\textgreater{}\ \textless{}object\ name\textgreater{}}
--- were chosen to make the programming steps as clear as possible.

\hypertarget{acknowledgments}{%
\subsubsection{Acknowledgments}\label{acknowledgments}}

Thanks to Tom Agresta for valuable advice on the tutorial.

If you think this notebook omits some essential functionality, or if it
has become out of date, feel free to contact me to suggest it! Or, if
you have a clear idea how it could be used in this example workflow,
follow the guidelines in
\href{https://github.com/MIT-LCP/mimic-code}{the README} to contribute
to the repo.

\hypertarget{setup}{%
\subsection{Setup}\label{setup}}

This R Markdown notebook relies on \textbf{knitr} to render an HTML
document, but users should be able to reproduce its content without that
package.

\hypertarget{attach-r-packages}{%
\subsubsection{Attach R packages}\label{attach-r-packages}}

This minimal introduction relies (directly) on two packages:
\textbf{RPostgreSQL} connects to databases using PostgreSQL
(``Postgres'') functionality from the \textbf{DBI} package, while
\textbf{dplyr} provides a grammar of data manipulation based on the same
relational algebra as SQL itself. Internally, \textbf{dplyr} calls upon
the \textbf{dbplyr} package in order to connect to a database, translate
\textbf{dplyr} verbs into SQL queries, and display their
results.\footnote{I originally tried to produce this notebook using
  \href{https://github.com/r-dbi/RPostgres}{\textbf{RPostgres}}, a newer
  interface to Postgres developed by the \textbf{tidyverse}-adjacent
  \textbf{r-dbi} team. I failed, but that shouldn't discourage anyone
  from giving it a try. I'll try again myself in a future draft or a
  separate notebook.} I'll also use functions from \textbf{stringr} in a
few queries.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(RPostgreSQL)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: DBI
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attaching package: 'dplyr'
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:stats':
## 
##     filter, lag
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(stringr)}
\end{Highlighting}
\end{Shaded}

\hypertarget{instantiate-the-mimic-iii-database}{%
\subsubsection{Instantiate the MIMIC-III
database}\label{instantiate-the-mimic-iii-database}}

I followed
\href{https://mimic.physionet.org/tutorials/install-mimic-locally-ubuntu/}{the
Unix/Mac instructions at PhysioNet} to create an instance of
MIMIC-III.\footnote{The instantiation required some changes to the
  Postgres commands, e.g.~\texttt{alter\ user\ mimic\ nosuperuser;}
  should in fact be \texttt{alter\ user\ mimicuser\ nosuperuser;}.} In
particular, i used the user name (\texttt{mimicuser}), database name
(\texttt{mimic}), and schema name (\texttt{mimiciii}) suggested there,
with the password \texttt{mimic}. If you make different choices, then
you'll need to change the corresponding parameter values in the
\texttt{dbConnect()} call below. While the queries in this notebook can
be performed on the entire database, a user new to MIMIC, Postgres, or R
may want to install
\href{https://mimic.physionet.org/gettingstarted/demo/}{the demo data
set} instead, following the same process except for the CSV files
used.\footnote{When installing a new database, i find it much more
  efficient to wrap my steps in an R script that i can execute from the
  top to erase the baggage from experimentation and errors. I just
  discovered \href{https://cran.r-project.org/package=etl}{the
  \textbf{etl} package}, and i hope in future to prepare an
  instantiation process for MIMIC-III from within R using it or a
  similar framework.}

\hypertarget{connect-to-mimic-iii}{%
\subsubsection{Connect to MIMIC-III}\label{connect-to-mimic-iii}}

I save the database connection to the variable name \texttt{mimic}. Once
connected, the \texttt{dbListTables()} function should return the names
of all tables in the database:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mimic }\OtherTok{\textless{}{-}} \FunctionTok{dbConnect}\NormalTok{(}
  \FunctionTok{PostgreSQL}\NormalTok{(),}
  \AttributeTok{dbname =} \StringTok{"mimic"}\NormalTok{,}
  \AttributeTok{host =} \StringTok{"localhost"}\NormalTok{,}
  \AttributeTok{port =} \DecValTok{5432}\NormalTok{,}
  \AttributeTok{user =} \StringTok{"mimicuser"}\NormalTok{,}
  \AttributeTok{password =} \StringTok{"mimic"}
\NormalTok{)}
\FunctionTok{dbListTables}\NormalTok{(mimic)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "admissions"         "d_icd_diagnoses"    "callout"           
##  [4] "caregivers"         "chartevents_1"      "chartevents_2"     
##  [7] "chartevents_3"      "chartevents_4"      "chartevents_5"     
## [10] "chartevents_6"      "chartevents_7"      "chartevents_8"     
## [13] "chartevents_9"      "chartevents_10"     "chartevents_11"    
## [16] "chartevents_12"     "chartevents_13"     "chartevents_14"    
## [19] "chartevents_15"     "chartevents_16"     "chartevents_17"    
## [22] "chartevents"        "cptevents"          "datetimeevents"    
## [25] "diagnoses_icd"      "drgcodes"           "d_cpt"             
## [28] "d_icd_procedures"   "d_items"            "d_labitems"        
## [31] "icustays"           "inputevents_cv"     "inputevents_mv"    
## [34] "labevents"          "microbiologyevents" "noteevents"        
## [37] "outputevents"       "patients"           "prescriptions"     
## [40] "procedureevents_mv" "procedures_icd"     "services"          
## [43] "transfers"          "dbplyr_001"
\end{verbatim}

\hypertarget{queries}{%
\subsection{Queries}\label{queries}}

\hypertarget{inspect-and-read-tables}{%
\subsubsection{Inspect and read tables}\label{inspect-and-read-tables}}

In \textbf{dplyr}, the \texttt{tbl()} function, which passes a database
connection to the \texttt{dplyr:::tbl.DBIConnection()} method, produces
a SQL tbl, i.e.~an object of class \texttt{"tbl\_sql"}, which also
inherits class \texttt{"tbl\_lazy"}. (Henceforth i'll just call this a
``query table''.) This object stores a simple inspection query on a
single table and executes it whenever the object is used (e.g., when
printed to the console). Indeed, a query table occupies only the memory
necessary to recover the query, so that many such objects can be stored
in a lightweight R session.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{patients }\OtherTok{\textless{}{-}} \FunctionTok{tbl}\NormalTok{(mimic, dbplyr}\SpecialCharTok{::}\FunctionTok{in\_schema}\NormalTok{(}\StringTok{"mimiciii"}\NormalTok{, }\StringTok{"patients"}\NormalTok{))}
\FunctionTok{object.size}\NormalTok{(patients)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4176 bytes
\end{verbatim}

Since conventional practice in R is to read a table into memory in its
entirety, this functionality also saves time --- at least, until it
becomes necessary to manipulate a table in ways that don't translate
easily into SQL. When this does become necessary, a \texttt{"tbl\_sql"}
object can be read into R using \texttt{collect()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rbenchmark}\SpecialCharTok{::}\FunctionTok{benchmark}\NormalTok{(}
  \AttributeTok{tbl\_query =} \FunctionTok{tbl}\NormalTok{(mimic, dbplyr}\SpecialCharTok{::}\FunctionTok{in\_schema}\NormalTok{(}\StringTok{"mimiciii"}\NormalTok{, }\StringTok{"d\_icd\_diagnoses"}\NormalTok{)),}
  \AttributeTok{dbi\_read =} \FunctionTok{dbReadTable}\NormalTok{(mimic, }\FunctionTok{c}\NormalTok{(}\StringTok{"mimiciii"}\NormalTok{, }\StringTok{"d\_icd\_diagnoses"}\NormalTok{)),}
  \AttributeTok{tbl\_read =} \FunctionTok{collect}\NormalTok{(}\FunctionTok{tbl}\NormalTok{(mimic, dbplyr}\SpecialCharTok{::}\FunctionTok{in\_schema}\NormalTok{(}\StringTok{"mimiciii"}\NormalTok{, }\StringTok{"d\_icd\_diagnoses"}\NormalTok{))),}
  \AttributeTok{replications =}\NormalTok{ 24L}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        test replications elapsed relative user.self sys.self user.child
## 2  dbi_read           24   1.032    4.914     0.591    0.094          0
## 1 tbl_query           24   0.210    1.000     0.157    0.007          0
## 3  tbl_read           24   1.388    6.610     0.899    0.094          0
##   sys.child
## 2         0
## 1         0
## 3         0
\end{verbatim}

As illustrated above, installing MIMIC-III in a schema imposes the
additional step of specifying this schema in each query. I prefer to
shortcut this step by defining a MIMIC-specific \texttt{tbl} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tbl\_mimic }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(table) \{}
\NormalTok{  table }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(}\FunctionTok{substitute}\NormalTok{(table))}
  \FunctionTok{tbl}\NormalTok{(mimic, dbplyr}\SpecialCharTok{::}\FunctionTok{in\_schema}\NormalTok{(}\StringTok{"mimiciii"}\NormalTok{, table))}
\NormalTok{\}}
\FunctionTok{tbl\_mimic}\NormalTok{(patients)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   table<"mimiciii"."patients"> [?? x 8]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    row_id subject_id gender dob                 dod                
##     <int>      <int> <chr>  <dttm>              <dttm>             
##  1    234        249 F      2075-03-13 00:00:00 NA                 
##  2    235        250 F      2164-12-27 00:00:00 2188-11-22 00:00:00
##  3    236        251 M      2090-03-15 00:00:00 NA                 
##  4    237        252 M      2078-03-06 00:00:00 NA                 
##  5    238        253 F      2089-11-26 00:00:00 NA                 
##  6    239        255 M      2109-08-05 00:00:00 NA                 
##  7    240        256 M      2086-07-31 00:00:00 NA                 
##  8    241        257 F      2031-04-03 00:00:00 2121-07-08 00:00:00
##  9    242        258 F      2124-09-19 00:00:00 NA                 
## 10    243        260 F      2105-03-23 00:00:00 NA                 
## # ... with more rows, and 3 more variables: dod_hosp <dttm>, dod_ssn <dttm>,
## #   expire_flag <int>
\end{verbatim}

Beware, though, that this shortcut is not as adaptable as \textbf{dplyr}
functions and may cause confusion if used in unintended ways,
e.g.~loops. A less flexible but safer function would omit the first
line, requiring the user to always pass a character string to the
\texttt{table} parameter.

\hypertarget{subset-and-join-query-tables}{%
\subsubsection{Subset and join query
tables}\label{subset-and-join-query-tables}}

A great deal more can be done with \textbf{dbplyr} --- that is, without
or before reading tables into R --- than inspect them. In the code
chunks below, i combine data from several tables to build an analytic
table of heart attack patients seen at the coronary care unit (CCU).

To begin, i create a query table for the unique admission events for
each patient, which serves as the anchor for the rest of the analysis. I
want to limit my analysis to patients admitted directly to the CCU, so
i'll need care unit information for each admission. For this reason, i
query admissions from \texttt{transfers}, which includes the
\texttt{prev\_careunit} and \texttt{curr\_careunit} fields, rather than
from \texttt{admissions}. I use \texttt{filter()} to restrict to CCU
admissions; \texttt{prev\_careunit} takes the value \texttt{NA} for
admissions from outside the hospital, and in these instances
\texttt{curr\_careunit} indicates the starting unit.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(transfers) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, hadm\_id, prev\_careunit, curr\_careunit) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(prev\_careunit) }\SpecialCharTok{\&}\NormalTok{ curr\_careunit }\SpecialCharTok{==} \StringTok{"CCU"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, hadm\_id) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{distinct}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ ccu\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 2]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id
##         <int>   <int>
##  1      85245  181887
##  2       8861  109419
##  3       4875  155268
##  4      14975  113621
##  5      21265  140906
##  6       9253  185074
##  7      49094  129618
##  8      31153  199555
##  9       7102  112951
## 10       9070  109439
## # ... with more rows
\end{verbatim}

Note my use of the pipe operator \texttt{\%\textgreater{}\%} from the
\textbf{magrittr} package, which is re-exported by \textbf{dplyr}. There
are several good arguments for using the pipe in manual R scripts, my
personal favorite being that i can, in RStudio (where my manual
scripting happens), select--execute the first several steps in a piped
sequence using \texttt{command+return} (\texttt{Ctrl+Enter} in Windows).

To restrict to heart attack patients, i need to identify a suitable set
of diagnosis codes. I could enter these manually if necessary, but for
efficiency i can search for the string ``myocardial infarction'' in the
\texttt{"long\_title"} field of the \texttt{d\_icd\_diagnoses} table.
String searches using \textbf{stringr} are
\href{https://github.com/tidyverse/dbplyr/pull/35}{translatable into SQL
as of 2017}), and i use \texttt{tolower()} to allow any capitalization.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(d\_icd\_diagnoses) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{str\_detect}\NormalTok{(}\FunctionTok{tolower}\NormalTok{(long\_title), }\StringTok{"myocardial infarction"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ mi\_codes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 4]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    row_id icd9_code short_title        long_title                               
##     <int> <chr>     <chr>              <chr>                                    
##  1   4335 41000     AMI anterolateral~ Acute myocardial infarction of anterolat~
##  2   4336 41001     AMI anterolateral~ Acute myocardial infarction of anterolat~
##  3   4337 41002     AMI anterolateral~ Acute myocardial infarction of anterolat~
##  4   4338 41010     AMI anterior wall~ Acute myocardial infarction of other ant~
##  5   4339 41011     AMI anterior wall~ Acute myocardial infarction of other ant~
##  6   4340 41012     AMI anterior wall~ Acute myocardial infarction of other ant~
##  7   4341 41020     AMI inferolateral~ Acute myocardial infarction of inferolat~
##  8   4342 41021     AMI inferolateral~ Acute myocardial infarction of inferolat~
##  9   4343 41022     AMI inferolateral~ Acute myocardial infarction of inferolat~
## 10   4344 41030     AMI inferopost, u~ Acute myocardial infarction of inferopos~
## # ... with more rows
\end{verbatim}

I can now look for myocardial infarction (MI) in the diagnosis record
for each admission, stored in the \texttt{diagnoses\_icd} table. Since
the relevant codes are contained in a query table, i can use
\texttt{semi\_join()} to restrict to admission entries that match these
codes, without keeping any fields from the codes table.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(diagnoses\_icd) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{semi\_join}\NormalTok{(mi\_codes, }\AttributeTok{by =} \StringTok{"icd9\_code"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ mi\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 5]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    row_id subject_id hadm_id seq_num icd9_code
##     <int>      <int>   <int>   <int> <chr>    
##  1 175785      15805  188616       1 41000    
##  2 281839      25208  167918       7 41000    
##  3    594         73  194730       1 41001    
##  4   6395        543  115307       1 41001    
##  5   6630        571  193189       1 41001    
##  6  11015        947  122379       1 41001    
##  7  12916       1114  164691       2 41001    
##  8  14945       1317  198886       1 41001    
##  9  18340       1626  117062       1 41001    
## 10  30343       2700  100335       1 41001    
## # ... with more rows
\end{verbatim}

MI may not be listed as the principal diagnosis; as explained in
\href{https://mimic.physionet.org/mimictables/diagnoses_icd/}{the
documentation for the \texttt{patients} table}, the \texttt{seq\_num}
field is a priority ranking for the diagnoses generated at the end of
stay. In order to focus on patients for whom MI was central to their
hospitalization, i will include records with MI in any of the first five
diagnosis positions, according to the \texttt{"seq\_num"} field. To
avoid duplicate admissions, i use \texttt{group\_by()} and
\texttt{top\_n()} to limit the query to the first MI diagnosis for each
admission.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(seq\_num }\SpecialCharTok{\textless{}=} \DecValTok{5}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(subject\_id, hadm\_id) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice\_min}\NormalTok{(}\AttributeTok{order\_by =}\NormalTok{ seq\_num) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, hadm\_id, icd9\_code, seq\_num) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ mi\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:     lazy query [?? x 4]
## # Database:   postgres 9.6.20 [mimicuser@localhost:5432/mimic]
## # Ordered by: seq_num
##    subject_id hadm_id icd9_code seq_num
##         <int>   <int> <chr>       <int>
##  1         24  161859 41041           1
##  2         28  162569 412             4
##  3         42  119203 412             4
##  4         53  155385 41021           1
##  5         73  194730 41001           1
##  6         79  181542 41011           1
##  7        108  123552 412             5
##  8        111  192123 41081           5
##  9        123  195632 41011           1
## 10        149  154869 41011           1
## # ... with more rows
\end{verbatim}

I now have one query table of admissions to the CCU and another of
admissions that included an MI diagnosis. To get the information
contained in either table for the admission events contained in both, i
inner-join them. While the resulting new table will be annotated with
additional fields, it will not be subsetted further, so i just call it
\texttt{study\_admissions}. For a thorough discussion of the joins
implemented in \textbf{dplyr}, check out
\href{https://r4ds.had.co.nz/relational-data.html}{the chapter on
relational algebra in the book \emph{R for Data Science}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ccu\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{inner\_join}\NormalTok{(mi\_admissions, }\AttributeTok{by =} \FunctionTok{c}\NormalTok{(}\StringTok{"subject\_id"}\NormalTok{, }\StringTok{"hadm\_id"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 4]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id icd9_code seq_num
##         <int>   <int> <chr>       <int>
##  1      49094  129618 41011           1
##  2       6070  118910 41091           1
##  3      90418  195748 41011           3
##  4      54971  112750 41041           1
##  5      83977  195416 41091           1
##  6      12987  156603 41041           1
##  7      11531  161667 41011           1
##  8      17647  180968 41091           5
##  9      87228  194663 41011           1
## 10      77696  121542 41041           1
## # ... with more rows
\end{verbatim}

\hypertarget{transform-and-augment-query-tables}{%
\subsubsection{Transform and augment query
tables}\label{transform-and-augment-query-tables}}

I made the decision earlier to focus on admissions for which MI was
entered into one of the first five diagnosis fields, but it may be
useful in the analysis to control for MI being the principal diagnosis.
I can introduce a new variable to flag those admissions for which it is
first, according to \texttt{seq\_num}, using the \texttt{mutate()}
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{principal\_dx =}\NormalTok{ seq\_num }\SpecialCharTok{==} \DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{seq\_num) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 4]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id icd9_code principal_dx
##         <int>   <int> <chr>     <lgl>       
##  1      49094  129618 41011     TRUE        
##  2       6070  118910 41091     TRUE        
##  3      90418  195748 41011     FALSE       
##  4      54971  112750 41041     TRUE        
##  5      83977  195416 41091     TRUE        
##  6      12987  156603 41041     TRUE        
##  7      11531  161667 41011     TRUE        
##  8      17647  180968 41091     FALSE       
##  9      87228  194663 41011     TRUE        
## 10      77696  121542 41041     TRUE        
## # ... with more rows
\end{verbatim}

Some records include additional information about the severity of
patients' ailments, used for billing purposes. The \texttt{drgcodes}
table contains, for DRG codes from the All Payers Registry (APR),
severity and mortality indicators. I restrict to APR drug codes using
another string search, then join severity scores to the admissions query
table, using a right-join so as not to drop any admissions who happened
to not receive APR drugs. I assign patients with no APR codes the lowest
severity score.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(drgcodes) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{str\_detect}\NormalTok{(drg\_type, }\StringTok{"APR"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, hadm\_id, drg\_severity) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{right\_join}\NormalTok{(study\_admissions, }\AttributeTok{by =} \FunctionTok{c}\NormalTok{(}\StringTok{"subject\_id"}\NormalTok{, }\StringTok{"hadm\_id"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{drg\_severity =} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(drg\_severity), }\DecValTok{1}\NormalTok{, drg\_severity)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 5]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id drg_severity icd9_code principal_dx
##         <int>   <int>        <dbl> <chr>     <lgl>       
##  1      49094  129618            1 41011     TRUE        
##  2      49094  129618            1 41011     TRUE        
##  3       6070  118910            1 41091     TRUE        
##  4      90418  195748            4 41011     FALSE       
##  5      90418  195748            4 41011     FALSE       
##  6      54971  112750            1 41041     TRUE        
##  7      54971  112750            1 41041     TRUE        
##  8      83977  195416            3 41091     TRUE        
##  9      83977  195416            3 41091     TRUE        
## 10      12987  156603            1 41041     TRUE        
## # ... with more rows
\end{verbatim}

Finally, i adopt a common outcome measure for critical care: 30-day
mortality. I'm interested in survival after discharge, so i must
restrict to patients who did \emph{not} die in hospital. This
information is recorded in the \texttt{"hospital\_expire\_flag"} field
(though not yet described in
\href{https://mimic.physionet.org/mimictables/admissions/}{the
\texttt{admissions} table documentation}; see
\href{https://mimic.physionet.org/tutorials/intro-to-mimic-iii/}{the
tutorial on querying MIMIC-III}). I also require the dates (admission
and discharge) of each stay from the \texttt{admissions} table and the
date of death (where available) of each patient from the
\texttt{patients} table. While i'm working with dates, i'll also
calculate each patient's age on the day of admission.

I first join the necessary date fields into \texttt{study\_admissions}.
The syntax gets a bit cluttered here in order to keep the query to one
pipeline. This is my own preference; you may prefer, especially while
familiarizing yourself with \textbf{dplyr}, to cut these into smaller
chunks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(}
    \FunctionTok{select}\NormalTok{(}
      \FunctionTok{tbl\_mimic}\NormalTok{(admissions),}
\NormalTok{      subject\_id, hadm\_id, admittime, dischtime, hospital\_expire\_flag}
\NormalTok{    ),}
    \AttributeTok{by =} \FunctionTok{c}\NormalTok{(}\StringTok{"subject\_id"}\NormalTok{, }\StringTok{"hadm\_id"}\NormalTok{)}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(hospital\_expire\_flag }\SpecialCharTok{==} \DecValTok{0}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{hospital\_expire\_flag) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(}
    \FunctionTok{select}\NormalTok{(}\FunctionTok{tbl\_mimic}\NormalTok{(patients), subject\_id, dob, dod),}
    \AttributeTok{by =} \StringTok{"subject\_id"}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 9]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id drg_severity icd9_code principal_dx admittime          
##         <int>   <int>        <dbl> <chr>     <lgl>        <dttm>             
##  1      49094  129618            1 41011     TRUE         2177-05-01 21:03:00
##  2      49094  129618            1 41011     TRUE         2177-05-01 21:03:00
##  3       6070  118910            1 41091     TRUE         2195-01-20 23:53:00
##  4      90418  195748            4 41011     FALSE        2200-07-04 01:24:00
##  5      90418  195748            4 41011     FALSE        2200-07-04 01:24:00
##  6      54971  112750            1 41041     TRUE         2174-01-12 02:07:00
##  7      54971  112750            1 41041     TRUE         2174-01-12 02:07:00
##  8      83977  195416            3 41091     TRUE         2163-05-06 19:25:00
##  9      83977  195416            3 41091     TRUE         2163-05-06 19:25:00
## 10      12987  156603            1 41041     TRUE         2180-02-22 23:30:00
## # ... with more rows, and 3 more variables: dischtime <dttm>, dob <dttm>,
## #   dod <dttm>
\end{verbatim}

Functionality for working with dates and times is not yet implemented in
\textbf{dbplyr}, but an invaluable feature of
\href{https://dbplyr.tidyverse.org/articles/sql-translation.html}{its
SQL translation} is that unrecognized functions pass through verbatim,
where Postgres will attempt to interpret them. This allows to use
\texttt{date\_part()} below to extract components of timestamp fields as
numbers. (Postgres also has a convenient \texttt{age()} function that
would simplify the code chunk below, but this produces a character
string that doesn't lend itself to analysis purposes.)
\href{https://mimic.physionet.org/mimictables/patients/}{The
documentation for the \texttt{patients} table} explains that patients of
90 years and older had their ages artificially inflated, so i've removed
these patients from my analysis. I reorder the fields toward the end in
order to show the results of the date calculations. In the last
transformation step, \texttt{everything()} adds in all the fields i
don't explicitly select.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{tt\_death =} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"day"}\NormalTok{, dod) }\SpecialCharTok{{-}} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"day"}\NormalTok{, dischtime)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{mortality =}\NormalTok{ tt\_death }\SpecialCharTok{\textless{}=} \DecValTok{30}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{age =} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"year"}\NormalTok{, admittime) }\SpecialCharTok{{-}} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"year"}\NormalTok{, dob)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(age }\SpecialCharTok{\textless{}} \DecValTok{90}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{age =}\NormalTok{ age }\SpecialCharTok{{-}} \FunctionTok{ifelse}\NormalTok{(}
    \FunctionTok{date\_part}\NormalTok{(}\StringTok{"month"}\NormalTok{, admittime) }\SpecialCharTok{\textless{}} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"month"}\NormalTok{, dob) }\SpecialCharTok{|}
\NormalTok{      (}
        \FunctionTok{date\_part}\NormalTok{(}\StringTok{"month"}\NormalTok{, admittime) }\SpecialCharTok{==} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"month"}\NormalTok{, dob) }\SpecialCharTok{\&}
          \FunctionTok{date\_part}\NormalTok{(}\StringTok{"day"}\NormalTok{, admittime) }\SpecialCharTok{\textless{}} \FunctionTok{date\_part}\NormalTok{(}\StringTok{"day"}\NormalTok{, dob)}
\NormalTok{      ),}
    \DecValTok{1}\NormalTok{,}
    \DecValTok{0}
\NormalTok{  )) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{admittime, }\SpecialCharTok{{-}}\NormalTok{dischtime, }\SpecialCharTok{{-}}\NormalTok{dob, }\SpecialCharTok{{-}}\NormalTok{dod, }\SpecialCharTok{{-}}\NormalTok{tt\_death) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, hadm\_id, age, mortality, }\FunctionTok{everything}\NormalTok{()) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 7]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id   age mortality drg_severity icd9_code principal_dx
##         <int>   <int> <dbl> <lgl>            <dbl> <chr>     <lgl>       
##  1      49094  129618    32 NA                   1 41011     TRUE        
##  2      49094  129618    32 NA                   1 41011     TRUE        
##  3       6070  118910    60 TRUE                 1 41091     TRUE        
##  4      90418  195748    38 NA                   4 41011     FALSE       
##  5      90418  195748    38 NA                   4 41011     FALSE       
##  6      54971  112750    46 NA                   1 41041     TRUE        
##  7      54971  112750    46 NA                   1 41041     TRUE        
##  8      83977  195416    66 TRUE                 3 41091     TRUE        
##  9      83977  195416    66 TRUE                 3 41091     TRUE        
## 10      12987  156603    57 TRUE                 1 41041     TRUE        
## # ... with more rows
\end{verbatim}

Many \texttt{mortality} indicators are missing, due to neither the
hospital database nor the social security database having a record of
these patients' deaths. I could convert these to \texttt{FALSE} values,
but it may be helpful to retain in the analytic table this information
on whether deaths were recorded at all, e.g.~for validation or
sensitivity testing.

\hypertarget{collect-and-copy-into-query-tables}{%
\subsubsection{Collect and copy into query
tables}\label{collect-and-copy-into-query-tables}}

The next several steps take advantage of \textbf{dbplyr} functionality
to read (``collect'') query tables into an R session and, more
significantly, to join information from an R data frame into a query
table \emph{without} reading the query table into R. This can come in
handy when, for example, augmenting large database tables with simple
categorical values.

This illustration uses demographic information contained in MIMIC-III.
Patients' needs vary by sex, and our experiences with health care also
tend to reflect both ethnic and gender disparities. These disparities
can be accounted for to some extent using two demographic variables: the
\texttt{ethnicity} field in the \texttt{admissions} table and the
\texttt{gender} field in the \texttt{patients} table. I combine them
using a full join, so as to include even partial information on any
patient for whom it is available, and then use a semi-join to restrict
the result to those patients in the \texttt{study\_admissions} query
table.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(admissions) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, ethnicity) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{distinct}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_subjects}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 2]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id ethnicity            
##         <int> <chr>                
##  1      47247 ASIAN                
##  2       2497 WHITE                
##  3      32096 WHITE                
##  4      12064 WHITE                
##  5      29289 WHITE                
##  6      24001 UNKNOWN/NOT SPECIFIED
##  7      65985 WHITE                
##  8      29021 WHITE                
##  9      17663 ASIAN                
## 10      60733 WHITE                
## # ... with more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tbl\_mimic}\NormalTok{(patients) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, gender) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{distinct}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{full\_join}\NormalTok{(study\_subjects, }\AttributeTok{by =} \StringTok{"subject\_id"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_subjects}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 3]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id gender ethnicity             
##         <int> <chr>  <chr>                 
##  1      13317 M      WHITE                 
##  2       6317 F      BLACK/AFRICAN AMERICAN
##  3      98347 M      UNKNOWN/NOT SPECIFIED 
##  4      98347 M      WHITE                 
##  5      28215 F      BLACK/AFRICAN AMERICAN
##  6      29208 M      UNKNOWN/NOT SPECIFIED 
##  7       6422 F      WHITE                 
##  8      22426 M      WHITE                 
##  9      24792 M      WHITE                 
## 10       2194 F      WHITE                 
## # ... with more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_subjects }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{semi\_join}\NormalTok{(study\_admissions, }\AttributeTok{by =} \StringTok{"subject\_id"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_subjects}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # Source:   lazy query [?? x 3]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id gender ethnicity            
##         <int> <chr>  <chr>                
##  1      29208 M      UNKNOWN/NOT SPECIFIED
##  2       3674 M      UNKNOWN/NOT SPECIFIED
##  3       7616 F      OTHER                
##  4      26638 F      WHITE                
##  5       3569 M      WHITE                
##  6       2534 M      UNKNOWN/NOT SPECIFIED
##  7      22588 M      WHITE                
##  8      61115 F      WHITE                
##  9       6581 M      WHITE                
## 10      12708 F      WHITE                
## # ... with more rows
\end{verbatim}

There is much diversity and inconsistency in the \texttt{ethnicity}
field, along with many small numbers. I therefore collapse the field
into four main categories (Asian, Black, Hispanic, and white), with a
fifth \texttt{NA} value for smaller groups. These assignments could be
done within query tables; but the \texttt{study\_admissions} table is
already subsetted to the final set of patient admissions, so at this
stage it's just as well to commit queries to session memory. This allows
us to use the convenient \texttt{case\_when()} function to collapse the
ethnic categories.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unknown\_ethnicity }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}
  \StringTok{"OTHER"}\NormalTok{,}
  \StringTok{"UNABLE TO OBTAIN"}\NormalTok{,}
  \StringTok{"UNKNOWN/NOT SPECIFIED"}\NormalTok{,}
  \StringTok{"MULTI RACE ETHNICITY"}\NormalTok{,}
  \StringTok{"PATIENT DECLINED TO ANSWER"}\NormalTok{,}
  \StringTok{"UNKNOWN"}
\NormalTok{)}
\NormalTok{study\_subjects }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{collect}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{ethnic\_group =} \FunctionTok{case\_when}\NormalTok{(}
    \FunctionTok{str\_detect}\NormalTok{(ethnicity, }\StringTok{"\^{}ASIAN"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"ASIAN"}\NormalTok{,}
    \FunctionTok{str\_detect}\NormalTok{(ethnicity, }\StringTok{"\^{}BLACK"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"BLACK"}\NormalTok{,}
    \FunctionTok{str\_detect}\NormalTok{(ethnicity, }\StringTok{"\^{}HISPANIC"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"HISPANIC"}\NormalTok{,}
    \FunctionTok{str\_detect}\NormalTok{(ethnicity, }\StringTok{"\^{}WHITE"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"WHITE"}\NormalTok{,}
\NormalTok{    ethnicity }\SpecialCharTok{\%in\%}\NormalTok{ unknown\_ethnicity }\SpecialCharTok{\textasciitilde{}} \ConstantTok{NA\_character\_}\NormalTok{,}
    \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}} \ConstantTok{NA\_character\_}
\NormalTok{  )) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, gender, ethnic\_group) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_subjects}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1,203 x 3
##    subject_id gender ethnic_group
##         <int> <chr>  <chr>       
##  1         24 M      WHITE       
##  2         42 M      <NA>        
##  3         53 M      <NA>        
##  4         73 F      WHITE       
##  5        111 F      WHITE       
##  6        123 M      HISPANIC    
##  7        154 M      WHITE       
##  8        158 M      WHITE       
##  9        160 F      WHITE       
## 10        194 M      BLACK       
## # ... with 1,193 more rows
\end{verbatim}

In rare cases, a patient is coded as belonging to more than one ethnic
group. To resolve these inconsistencies, i've defined a helper function
to pick the modal value from a vector of values in R, which can be used
by the \texttt{summarize()} function to choose one ethnic group for each
patient.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{most }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(x))) }\FunctionTok{return}\NormalTok{(}\ConstantTok{NA\_character\_}\NormalTok{)}
\NormalTok{  y }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(x, }\AttributeTok{useNA =} \StringTok{"no"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{length}\NormalTok{(}\FunctionTok{which}\NormalTok{(y }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(y))) }\SpecialCharTok{\textgreater{}} \DecValTok{1}\NormalTok{) }\FunctionTok{return}\NormalTok{(}\ConstantTok{NA\_character\_}\NormalTok{)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{names}\NormalTok{(y)[}\FunctionTok{which.max}\NormalTok{(y)])}
\NormalTok{\}}
\NormalTok{study\_subjects }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(subject\_id) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{ethnic\_group =} \FunctionTok{most}\NormalTok{(ethnic\_group)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{ethnic\_group =} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(ethnic\_group), }\StringTok{"UNKNOWN"}\NormalTok{, ethnic\_group)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ subject\_ethnic\_groups}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1,188 x 2
##    subject_id ethnic_group
##  *      <int> <chr>       
##  1         24 WHITE       
##  2         42 UNKNOWN     
##  3         53 UNKNOWN     
##  4         73 WHITE       
##  5        111 WHITE       
##  6        123 HISPANIC    
##  7        154 WHITE       
##  8        158 WHITE       
##  9        160 WHITE       
## 10        194 BLACK       
## # ... with 1,178 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_subjects }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(subject\_id, gender) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(subject\_ethnic\_groups, }\AttributeTok{by =} \StringTok{"subject\_id"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_subjects}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1,203 x 3
##    subject_id gender ethnic_group
##         <int> <chr>  <chr>       
##  1         24 M      WHITE       
##  2         42 M      UNKNOWN     
##  3         53 M      UNKNOWN     
##  4         73 F      WHITE       
##  5        111 F      WHITE       
##  6        123 M      HISPANIC    
##  7        154 M      WHITE       
##  8        158 M      WHITE       
##  9        160 F      WHITE       
## 10        194 M      BLACK       
## # ... with 1,193 more rows
\end{verbatim}

While these subject data are small enough to store in memory, it's
conceivable that the admissions data remain prohibitively large. So, as
a final step, i can join these demographic data into the
\texttt{study\_admissions} query table by introducing a temporary copy
of \texttt{study\_subjects} in the MIMIC-III database, as described
\href{https://dbplyr.tidyverse.org/reference/join.tbl_sql.html}{in the
\textbf{dbplyr} documentation}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(study\_subjects, }\AttributeTok{by =} \StringTok{"subject\_id"}\NormalTok{, }\AttributeTok{copy =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{() }\OtherTok{{-}\textgreater{}}\NormalTok{ study\_admissions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in postgresqlWriteTable(conn, name, value, ...): table dbplyr_001 exists
## in database: aborting assignTable
\end{verbatim}

\begin{verbatim}
## # Source:   lazy query [?? x 9]
## # Database: postgres 9.6.20 [mimicuser@localhost:5432/mimic]
##    subject_id hadm_id   age mortality drg_severity icd9_code principal_dx gender
##         <int>   <int> <dbl> <lgl>            <dbl> <chr>     <lgl>        <chr> 
##  1      49094  129618    32 NA                   1 41011     TRUE         M     
##  2      49094  129618    32 NA                   1 41011     TRUE         M     
##  3       6070  118910    60 TRUE                 1 41091     TRUE         M     
##  4      90418  195748    38 NA                   4 41011     FALSE        M     
##  5      90418  195748    38 NA                   4 41011     FALSE        M     
##  6      54971  112750    46 NA                   1 41041     TRUE         M     
##  7      54971  112750    46 NA                   1 41041     TRUE         M     
##  8      83977  195416    66 TRUE                 3 41091     TRUE         F     
##  9      83977  195416    66 TRUE                 3 41091     TRUE         F     
## 10      12987  156603    57 TRUE                 1 41041     TRUE         M     
## # ... with more rows, and 1 more variable: ethnic_group <chr>
\end{verbatim}

The analytic table is now analysis-ready! This query table can be piped
into statistical summaries, data visualizations, and other operations
that perhaps don't require saving intermittent steps; just beware that
some operations may not work with query tables, in which case
\texttt{collect()} should resolve the problem.

\hypertarget{appendix}{%
\subsubsection{Appendix}\label{appendix}}

For reference, here are my system specs and session info while knitting
this notebook:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sessioninfo}\SpecialCharTok{::}\FunctionTok{session\_info}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## - Session info ---------------------------------------------------------------
##  setting  value                       
##  version  R version 4.0.4 (2021-02-15)
##  os       macOS High Sierra 10.13.6   
##  system   x86_64, darwin17.0          
##  ui       X11                         
##  language (EN)                        
##  collate  en_US.UTF-8                 
##  ctype    en_US.UTF-8                 
##  tz       America/New_York            
##  date     2021-03-05                  
## 
## - Packages -------------------------------------------------------------------
##  package     * version date       lib source        
##  assertthat    0.2.1   2019-03-21 [1] CRAN (R 4.0.0)
##  blob          1.2.1   2020-01-20 [1] CRAN (R 4.0.0)
##  cli           2.3.1   2021-02-23 [1] CRAN (R 4.0.2)
##  crayon        1.4.1   2021-02-08 [1] CRAN (R 4.0.2)
##  DBI         * 1.1.0   2019-12-15 [1] CRAN (R 4.0.0)
##  dbplyr        2.0.0   2020-11-03 [1] CRAN (R 4.0.2)
##  debugme       1.1.0   2017-10-22 [1] CRAN (R 4.0.0)
##  digest        0.6.27  2020-10-24 [1] CRAN (R 4.0.2)
##  dplyr       * 1.0.4   2021-02-02 [1] CRAN (R 4.0.2)
##  ellipsis      0.3.1   2020-05-15 [1] CRAN (R 4.0.0)
##  evaluate      0.14    2019-05-28 [1] CRAN (R 4.0.0)
##  fansi         0.4.2   2021-01-15 [1] CRAN (R 4.0.2)
##  generics      0.1.0   2020-10-31 [1] CRAN (R 4.0.2)
##  glue          1.4.2   2020-08-27 [1] CRAN (R 4.0.0)
##  htmltools     0.5.0   2020-06-16 [1] CRAN (R 4.0.0)
##  knitr         1.30    2020-09-22 [1] CRAN (R 4.0.2)
##  lifecycle     1.0.0   2021-02-15 [1] CRAN (R 4.0.2)
##  magrittr      2.0.1   2020-11-17 [1] CRAN (R 4.0.2)
##  pillar        1.5.0   2021-02-22 [1] CRAN (R 4.0.0)
##  pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.0.0)
##  purrr         0.3.4   2020-04-17 [1] CRAN (R 4.0.0)
##  R6            2.5.0   2020-10-28 [1] CRAN (R 4.0.2)
##  rbenchmark    1.0.0   2012-08-30 [1] CRAN (R 4.0.2)
##  rlang         0.4.10  2020-12-30 [1] CRAN (R 4.0.2)
##  rmarkdown     2.5     2020-10-21 [1] CRAN (R 4.0.0)
##  RPostgreSQL * 0.6-2   2017-06-24 [1] CRAN (R 4.0.0)
##  rstudioapi    0.13    2020-11-12 [1] CRAN (R 4.0.2)
##  sessioninfo   1.1.1   2018-11-05 [1] CRAN (R 4.0.0)
##  stringi       1.5.3   2020-09-09 [1] CRAN (R 4.0.2)
##  stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)
##  tibble        3.1.0   2021-02-25 [1] CRAN (R 4.0.2)
##  tidyselect    1.1.0   2020-05-11 [1] CRAN (R 4.0.0)
##  utf8          1.1.4   2018-05-24 [1] CRAN (R 4.0.0)
##  vctrs         0.3.6   2020-12-17 [1] CRAN (R 4.0.2)
##  withr         2.4.1   2021-01-26 [1] CRAN (R 4.0.2)
##  xfun          0.19    2020-10-30 [1] CRAN (R 4.0.2)
##  yaml          2.2.1   2020-02-01 [1] CRAN (R 4.0.0)
## 
## [1] /Library/Frameworks/R.framework/Versions/4.0/Resources/library
\end{verbatim}

\end{document}
